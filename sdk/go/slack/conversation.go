// *** WARNING: this file was generated by pulumigen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package slack

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type Conversation struct {
	pulumi.CustomResourceState

	Channel    ChannelOutput            `pulumi:"channel"`
	IsArchived pulumi.BoolPtrOutput     `pulumi:"isArchived"`
	IsPrivate  pulumi.BoolPtrOutput     `pulumi:"isPrivate"`
	Members    pulumi.StringArrayOutput `pulumi:"members"`
	Name       pulumi.StringOutput      `pulumi:"name"`
	Purpose    pulumi.StringPtrOutput   `pulumi:"purpose"`
	Topic      pulumi.StringPtrOutput   `pulumi:"topic"`
}

// NewConversation registers a new resource with the given unique name, arguments, and options.
func NewConversation(ctx *pulumi.Context,
	name string, args *ConversationArgs, opts ...pulumi.ResourceOption) (*Conversation, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Name == nil {
		return nil, errors.New("invalid value for required argument 'Name'")
	}
	var resource Conversation
	err := ctx.RegisterResource("slack:index:Conversation", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetConversation gets an existing Conversation resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetConversation(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ConversationState, opts ...pulumi.ResourceOption) (*Conversation, error) {
	var resource Conversation
	err := ctx.ReadResource("slack:index:Conversation", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Conversation resources.
type conversationState struct {
}

type ConversationState struct {
}

func (ConversationState) ElementType() reflect.Type {
	return reflect.TypeOf((*conversationState)(nil)).Elem()
}

type conversationArgs struct {
	IsArchived *bool    `pulumi:"isArchived"`
	IsPrivate  *bool    `pulumi:"isPrivate"`
	Members    []string `pulumi:"members"`
	Name       string   `pulumi:"name"`
	Purpose    *string  `pulumi:"purpose"`
	Topic      *string  `pulumi:"topic"`
}

// The set of arguments for constructing a Conversation resource.
type ConversationArgs struct {
	IsArchived pulumi.BoolPtrInput
	IsPrivate  pulumi.BoolPtrInput
	Members    pulumi.StringArrayInput
	Name       pulumi.StringInput
	Purpose    pulumi.StringPtrInput
	Topic      pulumi.StringPtrInput
}

func (ConversationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*conversationArgs)(nil)).Elem()
}

type ConversationInput interface {
	pulumi.Input

	ToConversationOutput() ConversationOutput
	ToConversationOutputWithContext(ctx context.Context) ConversationOutput
}

func (*Conversation) ElementType() reflect.Type {
	return reflect.TypeOf((*Conversation)(nil))
}

func (i *Conversation) ToConversationOutput() ConversationOutput {
	return i.ToConversationOutputWithContext(context.Background())
}

func (i *Conversation) ToConversationOutputWithContext(ctx context.Context) ConversationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConversationOutput)
}

func (i *Conversation) ToConversationPtrOutput() ConversationPtrOutput {
	return i.ToConversationPtrOutputWithContext(context.Background())
}

func (i *Conversation) ToConversationPtrOutputWithContext(ctx context.Context) ConversationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConversationPtrOutput)
}

type ConversationPtrInput interface {
	pulumi.Input

	ToConversationPtrOutput() ConversationPtrOutput
	ToConversationPtrOutputWithContext(ctx context.Context) ConversationPtrOutput
}

type conversationPtrType ConversationArgs

func (*conversationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Conversation)(nil))
}

func (i *conversationPtrType) ToConversationPtrOutput() ConversationPtrOutput {
	return i.ToConversationPtrOutputWithContext(context.Background())
}

func (i *conversationPtrType) ToConversationPtrOutputWithContext(ctx context.Context) ConversationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConversationPtrOutput)
}

// ConversationArrayInput is an input type that accepts ConversationArray and ConversationArrayOutput values.
// You can construct a concrete instance of `ConversationArrayInput` via:
//
//          ConversationArray{ ConversationArgs{...} }
type ConversationArrayInput interface {
	pulumi.Input

	ToConversationArrayOutput() ConversationArrayOutput
	ToConversationArrayOutputWithContext(context.Context) ConversationArrayOutput
}

type ConversationArray []ConversationInput

func (ConversationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Conversation)(nil)).Elem()
}

func (i ConversationArray) ToConversationArrayOutput() ConversationArrayOutput {
	return i.ToConversationArrayOutputWithContext(context.Background())
}

func (i ConversationArray) ToConversationArrayOutputWithContext(ctx context.Context) ConversationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConversationArrayOutput)
}

// ConversationMapInput is an input type that accepts ConversationMap and ConversationMapOutput values.
// You can construct a concrete instance of `ConversationMapInput` via:
//
//          ConversationMap{ "key": ConversationArgs{...} }
type ConversationMapInput interface {
	pulumi.Input

	ToConversationMapOutput() ConversationMapOutput
	ToConversationMapOutputWithContext(context.Context) ConversationMapOutput
}

type ConversationMap map[string]ConversationInput

func (ConversationMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Conversation)(nil)).Elem()
}

func (i ConversationMap) ToConversationMapOutput() ConversationMapOutput {
	return i.ToConversationMapOutputWithContext(context.Background())
}

func (i ConversationMap) ToConversationMapOutputWithContext(ctx context.Context) ConversationMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConversationMapOutput)
}

type ConversationOutput struct {
	*pulumi.OutputState
}

func (ConversationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Conversation)(nil))
}

func (o ConversationOutput) ToConversationOutput() ConversationOutput {
	return o
}

func (o ConversationOutput) ToConversationOutputWithContext(ctx context.Context) ConversationOutput {
	return o
}

func (o ConversationOutput) ToConversationPtrOutput() ConversationPtrOutput {
	return o.ToConversationPtrOutputWithContext(context.Background())
}

func (o ConversationOutput) ToConversationPtrOutputWithContext(ctx context.Context) ConversationPtrOutput {
	return o.ApplyT(func(v Conversation) *Conversation {
		return &v
	}).(ConversationPtrOutput)
}

type ConversationPtrOutput struct {
	*pulumi.OutputState
}

func (ConversationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Conversation)(nil))
}

func (o ConversationPtrOutput) ToConversationPtrOutput() ConversationPtrOutput {
	return o
}

func (o ConversationPtrOutput) ToConversationPtrOutputWithContext(ctx context.Context) ConversationPtrOutput {
	return o
}

type ConversationArrayOutput struct{ *pulumi.OutputState }

func (ConversationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Conversation)(nil))
}

func (o ConversationArrayOutput) ToConversationArrayOutput() ConversationArrayOutput {
	return o
}

func (o ConversationArrayOutput) ToConversationArrayOutputWithContext(ctx context.Context) ConversationArrayOutput {
	return o
}

func (o ConversationArrayOutput) Index(i pulumi.IntInput) ConversationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Conversation {
		return vs[0].([]Conversation)[vs[1].(int)]
	}).(ConversationOutput)
}

type ConversationMapOutput struct{ *pulumi.OutputState }

func (ConversationMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]Conversation)(nil))
}

func (o ConversationMapOutput) ToConversationMapOutput() ConversationMapOutput {
	return o
}

func (o ConversationMapOutput) ToConversationMapOutputWithContext(ctx context.Context) ConversationMapOutput {
	return o
}

func (o ConversationMapOutput) MapIndex(k pulumi.StringInput) ConversationOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) Conversation {
		return vs[0].(map[string]Conversation)[vs[1].(string)]
	}).(ConversationOutput)
}

func init() {
	pulumi.RegisterOutputType(ConversationOutput{})
	pulumi.RegisterOutputType(ConversationPtrOutput{})
	pulumi.RegisterOutputType(ConversationArrayOutput{})
	pulumi.RegisterOutputType(ConversationMapOutput{})
}
